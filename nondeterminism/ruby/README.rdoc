This gem allows choose/fail (amb) style non-deterministic programming in
Ruby

Author::    Jim Wise  (mailto:jwise@draga.com)
Copyright:: Copyright (c) 2011 Jim Wise
License::   2-clause BSD-Style (see LICENSE[link:files/LICENSE.html])

= Introduction

This is an all-ruby implementation of choose/fail nondeterministic
programming with branch cut, as described in Chapter 22 of Paul Graham's
_On Lisp_[1], Chapter, or Section 4.3 of SICP[2].

This code will not work in JRuby or MacRuby (no callcc).  It should work
in 1.9.2 with minor changes (callcc has moved to the 'continuation'
stdlib).

Due to Ruby containing a true call/cc, this is a much straighter port of
Paul Graham's scheme version of this code than his Common Lisp or my C
versions are.  :-)

= What is Nondeterministic Programming?

Nondeterministic programming is a novel approach to problems where a
program must find a working solution out of many possible choices.  It
greatly simplifies problems such graph searching, testing combinations of
values, and so on, where there are many possible values to consider, often
in some sort of hierarchical order, but the right combination is not known
in advance.

In such a situation, it can be useful to develop a program by pretending
our programming language includes knowledge of the future -- and is thus
able to _choose_ the right answer off the bat, and simply programming as
if this is the case.

A language with support for nondeterministic programming (such as Ruby
with this gem) helps us keep up this pretense by saving the state of
computation (with some limits) whenever we make an important choice.  If
we later determine that we did _not_, in fact make the correct choice
(lacking true language support for knowing the future), we can _fail_ the
current computation, which _causes computation to rewind to the last
choice made, and continue as if a different choice had been made_).

When all possible choices have been tried, the next time computation
_fails_, computation will be rewound to the previous choice point, and
will continue with the next possible choice from there.

Imagine, for instance, that we wish to test a combination lock with a
three-number combination, with each number between 1 and 10, inclusive:
Instead of writing code ourself to try every possible combination, we
simply proceed as if each choice was the correct one, failing if the lock
fails to open.  In short:

   first = choose(1..10)
   second = choose(1..10)
   third = choose(1..10)

   fail! unless open_lock(first, second, third)

   # when we get here, lock is open!

As our language does not actually implement knowledge of the future, this
will still try as many combinations as are needed to find the right one --
but we can program as if it has chosen the right one on the first try!

= How to use this gem
== Choosing and Failing
== Marking and Cutting
== Interaction with Threading

= References

[1] Graham, Paul, _On Lisp_, Prentice Hall, 1993
    Available online at http://www.paulgraham.com/onlisp.html

[2] Abelson, Harold and Gerald Jay Sussman, _Structure and Interpretation
    of Computer Programs, 2nd Edition_, MIT Press, 1996
    Available online at http://mitpress.mit.edu/sicp/
